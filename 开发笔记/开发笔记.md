
# 1. 初始化
- 在github上新建仓库，忽略清单为node，开源协议为MIT，同时生成readme.md文件
- 使用`vue create web``vue create admin`来分别创建页面和后台的项目文件夹
- 新建server文件夹，用于存放node的代码，使用`npm init -y`初始化
- server文件夹下创建index.js作为服务端入口文件
- 在server/package.json中添加快速启动命令`"serve": "nodemon index.js"`
- 在admin下执行`vue add element`，引入element插件,执行`vue add router`,引入路由

## 1.1 前端——管理页面admin的初始工作

### admin初始页面内容
1. 在views下创建Main.vue页面（删掉router.js和App.vue里初始化的东西）
2. 将Element-ui的container代码直接复制上去（记得加上template标签）
3. 将在router.js中添加Main.vue的路由（默认路由设置为Main.vue）
4. 在App.vue中添加一些初始的样式

### main.vue中的子路由
在main.vue组件中，左边的下拉栏是超链接，点击的时候需要跳转到对应的页面去（比如点击新建分类就要跳转到新建分类的页面去），但是这个页面不是完全跳转的，而是就右边变化，左边是不动的，因此我们要给main.vue添加子路由

1. 在`<el-menu>`标签中添加router属性，同时修改子菜单的路由
  ![](./admin1.png)
  ![](./admin2.png)

2. 在router/index.js下给Main添加子路由
```js
children:[
      {path: 'categories/create', component: CategoryEdit}
]
```

## 1.2 服务端的初始工作
### 插件
`npm i express@next mongoose cors`分别安装三个插件，cors为允许跨域请求

### 入口文件
在server/index.js下写一些初始的代码
```js
// 引入express框架
const express = require('express')
// 使用框架创建web服务器
const app = express()

// 引入中间件
app.use(express.json())
// 引入cors插件
app.use(require('cors')())

// 分类路由文件
require('./routers/admin/index')(app)
// 连接数据库文件
require('./plugins/db')(app)

app.listen(3000,() => {
  console.log('http://localhost:3000')
})
```

> 写法说明：上面在引入分类路由文件和连接数据库文件的时候直接调用了，说明两文件在导出的时候都是导出一个函数。

### 路由
分类路由不直接写在server/index.js下，写在server/router/admin/index.js下
```js
module.exports = app => {
  const express = require('express')
  // 创建路由对象
  const router = express.Router()

  // 引入数据库categories集合
  const Category = require('../../models/Category')

  //创建二级路由
  router.post('/categories',async(req,res) => {
    // 向集合中插入文档
    const model = await Category.create(req.body)
    res.send(model)
  })

  //为路由对象匹配请求路径
  app.use('/admin/api',router)
}

```


### 数据库
- 连接数据库相关代码写在server/plugins/db.js
```js
module.exports = app => {
  const mongoose = require('mongoose')
  mongoose.connect('mongodb://localhost:27017/node-vue-moba', {
    useNewUrlParser: true,
    useUnifiedTopology: true
  })
}
```
- 数据库集合规则创建相关代码写在server/models/Category.js下，该模块导出一个规则
```js
const mongoose = require('mongoose')

// 创建集合规则
const schema = new mongoose.Schema({
  name: { type: String }
})

// 使用集合规则创建集合，创建的集合叫categories
module.exports = mongoose.model('Category', schema)
```

### axios
1. npm i axios安装
2. src目录下创建http.js
```js
import axios from 'axios'

const http = axios.create({
  baseURL: 'http://localhost:3000/admin/api'
})

export default http
```
3. 在main.js中将http挂载到vue原型上，方便使用
```js
import http from './http.js'
Vue.prototype.$http = http
```









# 2. 后台管理的功能实现



## 2.1 创建分类

创建CategoryEdit组件，当点击子菜单后右部分就会变成这个组件，而左边不变
- 创建一个input输入框和一个按钮，用v-model将input输入框和model.name数据进行双向绑定
- 给表单添加`@submit.native.prevent`，阻止默认提交，去调用save方法
  ![](./admin3.png)
```js
async save() {
      let res;
      if (this.id) {
        // 当编辑（更新）分类时
        res = await this.$http.put(`categories/${this.id}`, this.model);
      } else {
        // 当新建分类时
        res = await this.$http.post("categories", this.model);
      }
      this.$router.push("/categories/list");
      this.$message({
        type: "success",
        message: "保存成功",
      });
    },
```
## 2.2 显示分类

- 创建CategoryList.vue组件，用于显示创建的分类

```vue
<template>
  <el-table :data="items">
        <el-table-column prop="_id" label="ID" width="240"></el-table-column>
        <el-table-column prop="name" label="分类名称"></el-table-column>
        <el-table-column fixed="right" label="操作" width="100"></el-table-column>
  </el-table>
</template>

<script>
  data(){
    return{
      items: []
    }
  }
</script>
```
- 当组件被创建时，调用fetch方法，显示数据

```js
methods:{
  async fetch() {
      const res = await this.$http.get("categories");
      this.items = res.data;
    }
},
created(){
  this.fetch()
}
```
- 后端接口

```js
  //获取分类列表接口
  router.get('/categories', async (req, res) => {
    const items = await Category.find().limit(10)
    res.send(items)
  })
```

## 2.3 编辑分类
说白了就是更新分类

- CategoryList中的更新按钮
```vue
<template slot-scope="scope">
  <el-button
    type="text"
    size="small"
    @click="$router.push(`/categories/edit/${scope.row._id}`)"
    >编辑</el-button>
</template>
```

- 后端跳转到对应id分类编辑接口
```js
  //获取分类详情页接口
  router.get('/categories/:id', async (req, res) => {
    const model = await Category.findById(req.params.id)
    res.send(model)
  })
```

点击之后跳转到id对应路由，因此我们需要在router/index.js中添加路由

- router添加动态路由

```js
  path: 'categories/edit/:id',
  component: CategoryEdit,
  props: true
```

这个时候点击编辑按钮，页面就会跳转到新建分类上，我们还需要把分类名字默认的显示到input上，

- 给CategoryEdit的save方法升级一下，更新分类的时候用put方法接口，创建分类用post方法接口,
同时当分类更新时，this.model要更新，所以我们在created中加一层判断：当有id时，去请求id对应的数据并把它赋值给model
```vue
<script>
export default{
  props: {
    this.id: {}
  },
  methods:{
    async save() {
      let res;
      if (this.id) {
        // 当编辑（更新）分类时
        res = await this.$http.put(`categories/${this.id}`, this.model);
      } else {
        // 当新建分类时
        res = await this.$http.post("categories", this.model);
      }
      this.$router.push("/categories/list");
      this.$message({
        type: "success",
        message: "保存成功",
      });
    },
    async fetch() {
      const res = await this.$http.get(`categories/${this.id}`);
      this.model = res.data;
    },
  },
  created(){
    this.id && this.fetch()
  }
}
</script>
```


- 后端更新分类接口和请求对应id接口
```js
  //编辑（更新）分类接口
  router.put('/categories/:id', async (req, res) => {
    const model = await Category.findByIdAndUpdate(req.params.id, req.body)
    res.send(model)
  })
    //获取分类详情页接口
  router.get('/categories/:id', async (req, res) => {
    const model = await Category.findById(req.params.id)
    res.send(model)
  })
```

## 2.4 删除分类
- CategoryList中的删除按钮
```js
<el-button type="text" size="small" @click="remove(scope.row)">删除</el-button>

async remove(row) {
      // console.log(row)
      this.$confirm(`是否删除分类 "${row.name}"`, "提示", {
        confirmButtonText: "确定",
        cancelButtonText: "取消",
        type: "warning",
      })
        .then(async () => {
          const res = await this.$http.delete(`categories/${row._id}`)
          this.$message({
            type: "success",
            message: "删除成功!",
          });
          this.fetch()
        })
        .catch(() => {
          this.$message({
            type: "info",
            message: "已取消删除",
          });
        });
    },
```

当确定删除时调用delete接口

- 后端接口
```js
  //删除分类接口
  router.delete('/categories/:id', async (req, res) => {
    // 删除分类
    await Category.findByIdAndDelete(req.params.id, req.body)
    res.send({
      success: true
    })
  })
```

## 2.5 子分类
我们通过分类的id字段来表示父子层级关系，但是数据库中所有数据依然是扁平的

- 在CategoryEdit中添加上级分类选项
```vue
<template>
 <el-form-item label="上级分类">
   <el-select v-model="model.parent">
     <el-option 
     v-for="item in parents" 
     :key="item._id"
     :label="item.name"
     :value="item._id"></el-option>
   </el-select>
 </el-form-item>
</template>

<script>
export default {
  data(){
    return {
      parents: []
    }
  },
  methods:{
    async fetchParents(){
      const res = await this.$http.get(`categories`);
      this.parents = res.data;
    }
  },
  created() {
    this.fetchParents()
  }
}
</script>
```

当我们选择上级后，这个时候创建数据就会有id，name和parents，但是在数据库中我们并没有将parents插入，因此我们需要更改数据库创建集合规则

- server/model/Category.js
```js
const schema = new mongoose.Schema({
  name: {
    type: String
  },
  parent: {
    type: mongoose.SchemaTypes.ObjectId,
    ref: 'Category'
  }
})
```

parent已经被添加到数据库中，接下来做的就是展示

展示之前还要做一件事，我们现在直接展示的话展示的实际上是上级分类的id，我们要获取到他的name，因此改一下后端接口
```js
 //获取分类列表接口
  router.get('/categories', async (req, res) => {
    const items = await Category.find().populate('parent').limit(10)
    res.send(items)
  })
```
populate()在一个文档中引用另一个集合中的文档，并将其填充到指定文档路径中。

然后展示

- CategoryList.vue
```js
<el-table-column prop="parent.name" label="上级"></el-table-column>
```

## 2.6 通用接口

### 为什么用通用接口
前面做完了分类的增删改查，但是后面还有许多类似操作比如英雄的、装备的增删改查等等，操作几乎都一样，因此我们把它写成通用的接口
比如一个接口
```js
router.post('/categories', async (req, res) => {
  // 向集合中插入文档
  const model = await Category.create(req.body)
  res.send(model)
})
```
请求地址/categories是不一样的（比如英雄可能请求/hero），模型也是不一样的，除此之外别的几乎都一样，因此我们把这两个东西设置成动态生成的

这里可以发现，**categories路径对应的就是Category模型**，这是一个**命名规范**（复数变成单数，首字母大写）

### 开始改造

先在请求前缀加一个rest区分别的非通用接口，后面跟一个动态参数
```js
app.use('/admin/api/rest/:resource', router)
```
这个时候所有接口中的categories就能删掉了
```js
router.post('/', async (req, res) => {
  // 向集合中插入文档
  const model = await Category.create(req.body)
  res.send(model)
})
```
url改完了，这个时候就要更换接口里的模型了，这个模型不能写死，也是传入的url动态生成的
这个模型就类似于这样找
```js
const Model = require(`../../models/${req.params.resource}`)
```
这个resource参数是在app.use里定义的，不能直接在接口里面用，需要加一些东西
```js
const router = express.Router({
  mergeParams: true
})
```
这个东西表示合并url参数，将父级app的参数合并到子级router里面来，这个时候就能在接口里面使用resource了

虽然看似已经能通过url传入的resource来动态生成模型路径了，但有一个问题，url传入的比如是categories，但是我们应该找到Category模型，直接找肯定是找不到的，因此我们需要转换一下

这个时候就用到了一个插件inflection,`npm i inflection`，这个插件专门用来处理一些单复数转换、格式转换等等
所以这个时候我们就能这么写
```js
const modelName = require('inflection').classify(req.params.resource)
const Model = require(`../../models/${modelName}`)
```


这两行代码每个接口都要用，因此我们把它做成中间件，直接加到app.use中

```js
app.use('/admin/api/rest/:resource', async (req, res, next) => {
  const modelName = require('inflection').classify(req.params.resource)
  req.Model = require(`../../models/${modelName}`)
  next()
}, router)
```
注意不能`const Model`，那样写在接口里访问不到，我们写成`req.Model`，表示给请求对象挂载一个Model，这样在接口中我们就通过`req.Model`来获取模型
```js
router.post('/', async (req, res) => {
  // 向集合中插入文档
  const model = await req.Model.create(req.body)
  res.send(model)
})
```
到此，通用接口已经做好了，但是获取分类列表接口还有点问题要改。之前我们写的默认去调用populate方法
```js
router.get('/', async (req, res) => {
  const items = await req.Model.find().populate('parent').limit(10)
  res.send(items)
})
```
但既然是通用接口了，我们就需要去判断当前url是否为分类，如果是再去调用
```js
router.get('/', async (req, res) => {
  const queryOptions = {}
  if(req.Model.modelName === 'Category'){
    queryOptions.populate = 'parent'
  }
  const items = await req.Model.find().setOptions(queryOptions).limit(10)
  res.send(items)
})
```







## 2.7 物品管理

没啥说的，代码都是分类直接复制过来的改改，接口也直接能使用通用的，再创建一个模型就行了

## 2.8 图片上传

- 首先写前端界面

element-ui里面直接有Upload，复制到ItemEdit即可
```js
<el-upload
  class="avatar-uploader"
  :action="$http.default.baseURL + '/upload'"
  :show-file-list="false"
  :on-success="afterUpload"
>
  <img v-if="model.icon" :src="model.icon" class="avatar" />
  <i v-else class="el-icon-plus avatar-uploader-icon"></i>
</el-upload>
```
里面的action要传完整的路径，这个action走的是ajax，所以不能像`this.$http.put(`rest/categories/${this.id}`, this.model);`这种axios一样写。

当上传成功后调用afterUpload方法

- 后端接口
这个图片上传接口不能使用通用接口了，他的接口地址是`admin/api/upload`

这里要注意，express不能获取到上传的图片的数据，因此需要使用multer这个模块。`npm i multer`

> body-parser组件只能处理enctype="application/x-www-form-urlencoded"编码的数据，并放到req.body中，所以如果含有图片等数据，需要借助中间件，这里使用multer中间件

然后开始写接口。首先引入multer模块
```js
const multer = require('multer')
```
然后使用multer，将上传的图片传输到指定的文件夹中，我们在server/下创建uploads目录用来存放上传进来的图片
```js
const upload = multer({
  dest: __dirname + '/../../uploads'
})
```

最后是接口
```js
app.post('/admin/api/upload', upload.single('file'), async (req, res) => {
  const file = req.file
  file.url = `http://localhost:3000/uploads/${file.filename}`
  res.send(file)
})
```
`upload.single('file')`表示接收name为file的上传数据，接口中我们给file拼接一个url，前端调用这个url显示图片

后端就好了，然后是前端，当上传成功后调用afterUpload方法展示图片

- afterUpload方法
按理说直接这么写就行了
```js
this.model.icon = res.url
```

但是不行
> 确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property (比如 this.myObject.newProperty = 'hi')

普通添加的属性不能响应式，因此使用`$set`

但是想像开始那样写也可以，只需要先在model中把icon属性添加进去即可

```js
this.$set(this.model, 'icon', res.url)
```
这样图片就能显示出来了

- 最后在物品列表页面也展示图片

```js
<el-table-column prop="icon" label="图标">
  <template slot-scope="scope">
    <img :src="scope.row.icon" style="height: 3rem" />
  </template>
</el-table-column>
```
## 2.9 英雄管理
和物品管理很像，直接复制，分别搞个HeroEdit,HeroList 就行，里面改改，再创建一个模型

- 模型Hero.js
这次的模型东西挺多的，名字、头像、称号、职业、评分、技能、出装和各种技巧，需要注意的就是英雄搭档、出装、职业都是关联的，`type`都是`mongoose.SchemaTypes.ObjectId`

- HeroEdit.vue
说几个地方
  - 类型
  ```js
  <el-form-item label="类型">
    <el-select v-model="model.categories" multiple>
      <el-option
        v-for="item in categories"
        :label="item.name"
        :value="item._id"
        :key="item._id"
      ></el-option>
    </el-select>
  </el-form-item>
  ```
  用的是el-select，加上multiple表示能多选，注意el-select里的v-model里的categories是选出来的分类的数据，`v-for`循环的是请求过来的所有分类的数据，俩不一样

  - 评分
  用的是el-rate，传入`:max="8"`表示最大分值，show-score属性表示星星后面显示分值数字，注意v-model，他可能会找不到model.scores，这时候要再data的model中添加scores属性。

  然而这个时候有一个bug！当新建一个英雄的时候你会发现评分是没有问题的，但是编辑的时候就会报错说找不到scores，原因很简单，我们写的fetch方法里，当编辑英雄时这个model是从服务端拿过来的（直接替代的）
  ```js
  async fetch() {
    const res = await this.$http.get(`rest/heros/${this.id}`);
    this.model = res.data;
  }
  ```
  这时候拿到的model肯定没有score啊，所以我们不能让他直接替代，而是把数据添加进我们的model中
  ```js
  async fetch() {
    const res = await this.$http.get(`rest/heros/${this.id}`);
    this.model = Object.assign({}, this.model, res.data);
  },
  ```
  > Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。
  这里就是把我们的model和请求过来的数据都复制到一个空对象中，就是把俩放一块儿。这样就ok了


## 2.10 技能编辑

- 界面优化——卡片化
我们之前写的界面长这个样子
![](./技能.png)
如果再把技能往下加，就显得太乱了，所以我们把他变成标签页（选项卡）
```js
<el-tabs value="skills" type="border-card">
  <el-tab-pane label="基本信息" name="basic"></el-tab-pane>
  <el-tab-pane label="技能" name="skills"></el-tab-pane>
</el-tabs>
```
el-tabs的value为默认显示的标签页，传入的是标签页的名字，type为标签页样式，这里用卡片化的样式

之前写的基本信息的代码就全都放到basic下面，技能在skills下写

- 技能编辑
设想是这样的，首先有一个按钮为添加技能，点击一次出来一个添加技能的选项。
![](./技能2.png)
![](./技能3.png)
![](./技能4.png)

先在data下model里添加一个`skills:[]`，当点击这个按钮的时候就往数组里添加一个空对象
```js
 <el-button @click="model.skills.push({})">添加技能</el-button>
```
然后使用栅格布局
```js
<el-row type="flex" style="flex-wrap: wrap" :gutter="20">
  <el-col :md="12" v-for="(item, index) in model.skills" :key="index">
  </el-col>
</el-row>
```
  - row
    `type="flex"`表示使用flex布局
    `style="flex-wrap: wrap"`表示自动换行
    `:gutter="20"`表示每一栏之间间隔
  - col
    `:md="12"`表示在宽度>=992px的手机上显示的时候，栏宽为12。注意**栏宽总共就24**，设置成12就说明一行放俩这样子
    ![](./技能5.png)
    然后v-for循环遍历skills，每当skills有东西（这个东西就是按钮添加的空数组）时就创建出一个el-col。

el-col中有四项东西；名称 图标 描述 小贴士

这里要说一下图标。图标里面是el-upload，直接从头像那里拿过来用，但是on-success不能再调用afterUpload，而是直接写成一个函数
```js
:on-success='res => $set(item, "icon", res.icon)'
// 不能这么写，因为skills中原来并没有icon属性
res => item.icon=res.url
```

最后是技能删除。
添加一个el-button，type设置为danger，添加click事件
```js
 @click="model.skills.splice(index, 1)"
```
## 2.11 文章编辑
- 创建前端组件ArticleEdit和ArticleList，改一下里面的接口，直接能用通用接口
- 创建后端模型，Article.js，一个标题，一个所属分类，一个文章内容。这里注意文章内容得是富文本编辑器，不能是普通的表单
富文本编辑器可以用vue-quill-editor或者vue2-editor（本项目使用）

没啥说的，直接去npm看文档安装使用即可，但是有一个问题就是图片

如果往编辑器里直接上传图片的话会发现这个图片直接被保存成了base64编码，好处就是图片不需要往数据库里上传了，因为图片直接就在网页里了，但是坏处就是假如有好几张图片，一个接口就会很大，请求速度非常的慢。

当然了，这个包的文档中已经有自定义图片处理的代码了，直接拿过来用，但是稍微改改

## 2.12 广告管理
复制粘贴即可

# 3. 后台权限
## 3.1 管理员账号
- 还是那套复制粘贴编辑界面和列表界面，然后创建一个模型，

别的都没啥说的，好说的就是密码加密这里。
```js
const schema = new mongoose.Schema({
  username: {
    type: String
  },
  password: {
    type: String,
    // 本来是有什么就直接保存什么，但是加了set，表示自定义修改然后保存
    // 表示查询的时候不要带有这个（password）数据
    select: false,
    // 这里用了一个插件bcrypt，是一个加密算法，用于加密密码
    set(val) {
      return require('bcrypt').hashSync(val, 10)
    }
  }
})
```
这里要装一个插件bcrypt，他是一个加密算法，不可反向破解生成明文，是一个单向的hash算法。

```
hashSync(data, salt)
  data - [REQUIRED] - the data to be encrypted.

  salt - [REQUIRED] - the salt to be used to hash the password. if specified as a number then a salt will be generated with the specified number of rounds and used (see example under Usage).
```
传入的10是salt
> 所谓加Salt方法，就是加点“佐料”。其基本想法是这样的：当用户首次提供密码时（通常是注册时），由系统自动往这个密码里撒一些“佐料”，然后再散列。而当用户登录时，系统为用户提供的代码撒上同样的“佐料”，然后散列，再比较散列值，已确定密码是否正确。
> 这里的“佐料”被称作“Salt值”，这个值是由系统随机生成的，并且只有系统知道。这样，即便两个用户使用了同一个密码，由于系统为它们生成的salt值不同，他们的散列值也是不同的。即便黑客可以通过自己的密码和自己生成的散列值来找具有特定密码的用户，但这个几率太小了（密码和salt值都得和黑客使用的一样才行）。


## 3.2 登录
- 登陆界面，没啥说的，直接写，这个页面就不是在Main.vue里面了，而是一个单独的页面，路由也不是Main的子路由了。

- 后端接口
当前端点击登陆后，后端接口需要做三件事：
1. 根据用户名找用户
根据用户名查找用户，找不到的话要返回信息“用户不存在”，并且要给一个状态码表示异常
```js
const {
  username,
  password
} = req.body
// 1. 根据用户名找用户
const AdminUser = require('../../models/AdminUser')
const user = await AdminUser.findOne({
  username
})
// 查找用户是否存在
if (!user) {
  return res.status(422).send({
    message: '用户不存在'
  })
}
```
这个时候要在前端拦截到这个信息并展示出来，拦截应该是一个全局的拦截，所以在http.js中设置拦截器
```js
// 增加一个拦截器，这个是一个axios的api
http.interceptors.response.use(res => {
  return res
}, err => {
  if (err.response.data.message) {
    Vue.prototype.$message({
      type: 'error',
      message: err.response.data.message
    })
  }
  return Promise.reject(err)
})
```
`$message`是element-ui的消息弹窗，因为要在vue里使用，所以引入vue，并把它挂载到vue原型上
2. 校验密码
用bcrypt模块的compareSync方法对比用户输入的密码和数据库中存储的密码，用一个布尔值变量isValid保存，如果不相等返回422
```js
const isValid = require('bcrypt').compareSync(password, user.password)
if (!isValid) {
  return res.status(422).send({
    message: '密码错误'
  })
}
```
3. 返回token
返回token这里需要一个模块jwt（json web token）
用`jwt.sign`方法生成一个token，分别传入传入一个payload和secretOrPrivateKey。
这里payload传入的是用户的id，密钥用get方法去获取（注意这个get不是定义路由）
```js
const jwt = require('jsonwebtoken')
// 生成token
const token = jwt.sign({
  id: user._id,
  // 这里的get和定义路由的时候的get实际上是冲突的，只能通过传参个数来区分get的作用，传入一个表示获取参数，否则就是在获取配置
}, app.get('secret'))

res.send({
  token
})

```
这个get获取的是哪里的secret？这个secret应该是一个全局的变量，因此在serve/index.js中用set方法定义一个secret，后面的东西是随便写的
```js
app.set('secret','aasedwef')
```
- login.vue
说一下点击登录按钮后执行的方法
```js
async login() {
  const res = await this.$http.post("login", this.model);
  // 将服务器返回的token写入到localStorage（浏览器关闭之后，再打开还有）
  localStorage.token = res.data.token;
  // 如果想让浏览器关闭之后就没有的话用sessionStorage
  // sessionStorage.token = res.data.token
  this.$router.push("/");
  this.$message({
    type: "success",
    message: "登陆成功",
  });
},
```
首先调用后端接口，把后端返回的token存储在localStorage中，然后路由跳转到主页面，并且设置弹窗提示登陆成功


## 3.3 服务端登录校验 
上面完成了登录功能，并且在客户端中存入了token，但是我们并没有做任何的登陆限制，没有传入token也能访问所有的接口，所以我们要在服务端设置限制，只有有token的才能访问

### 前端发起请求的时候在请求头中加入token
```js
http.interceptors.request.use(function (config) {
  // 在前端，这个Authorization（授权）需要大写，在后端需要小写
  config.headers.Authorization = 'Bearer ' + localStorage.token
  return config
}, function (error) {
  return Promise.reject(error);
});
```
在授权请求头中添加授权，后面的token前面要注意加bearer，这是一个规范

### 后端验证
```js
  router.get('/', async (req, res, next) => {
    // 从请求头中获取token（注意在后端这个authorization要小写）
    const token = req.headers.authorization.split(' ')[1] || ''

    const {
      id
    } = jwt.verify(token, app.get('secret'))
    req.user = await AdminUser.findById(id)
    console.log(req.user);
    await next()
  }, async (req, res) => {
    const queryOptions = {}
    if (req.Model.modelName === 'Category') {
      queryOptions.populate = 'parent'
    }
    const items = await req.Model.find().setOptions(queryOptions).limit(10)
    res.send(items)
  })
```
以通用接口中的一个接口为例
在原来的操作前面添加一个中间件用于验证token
```js
// 中间的那个函数就是中间件
get('/', async(req,res) => {} async(req,res) => {})
```
首先从服务端获取token，注意获取到的token是这样的
```
Bearer GhndijfoFojasodj...
```
所以用split，参数为空格进行分割，分割后变成一个数组，拿到后面那项就是token了

然后用verify方法进行核实，这个方法返回这个东西
```js
{ id: '5f7c72046baf4235cc76f40b', iat: 1601991475 }
```
用解构赋值方式拿到id，然后根据id在数据库中查找到user，并把它挂到req上

3. 最后一步就是做判断
- 没有token、token错误、没登录的时候都要返回401状态码限制访问，并弹出“请先登录”的信息
- 登录时找不到用户、密码错误的情况下要返回422状态码，并弹出“用户不存在”、“密码错误”的信息

如果都用if语句写的话就太多太乱了，这里引用一个模块http-assert
这个模块是用来做判断并报错的，如果给定值不存在就会返回状态码和错误信息 
```
assert(value,statusCode,message)
```

登录接口：
```js
// 登录接口
app.post('/admin/api/login', async (req, res) => {
  const {
    username,
    password
  } = req.body
  // 1. 根据用户名找用户
  const user = await AdminUser.findOne({
    username
    // 默认是取不到password的，因为模型中设置select为false，这里用select方法，加号表示强制选择password
  }).select('+password')
  // 查找用户是否存在
  assert(user, 422, '用户不存在')
  // if (!user) {
  //   return res.status(422).send({
  //     message: '用户不存在'
  //   })
  // }
  // 2. 校验密码
  // 对比明文密码密码是否为散列后的hash值(即用户密码是否正确)
  const isValid = require('bcrypt').compareSync(password, user.password)
  assert(isValid, 422, '密码错误')
  // if (!isValid) {
  //   return res.status(422).send({
  //     message: '密码错误'
  //   })
  // }
  // 3. 返回token
  // 生成token
  const token = jwt.sign({
    id: user._id,
    // 这里的get和定义路由的时候的get实际上是冲突的，只能通过传参个数来区分get的作用，传入一个表示获取参数，否则就是在获取配置
  }, app.get('secret'))
  res.send({
    token
  })
})
```

获取资源列表接口：
```js
//获取资源列表接口
router.get('/', async (req, res, next) => {
  // 从请求头中获取token（注意在后端这个authorization要小写）
  const token = String(req.headers.authorization || '').split(' ')[1]
  assert(token, 401, '请提供jwt token')
  const {
    id
  } = jwt.verify(token, app.get('secret'))
  assert(id, 401, '无效的jwt token')
  req.user = await AdminUser.findById(id)
  assert(req.user, 401, '请先登录')
  await next()
}, async (req, res) => {
  const queryOptions = {}
  if (req.Model.modelName === 'Category') {
    queryOptions.populate = 'parent'
  }
  const items = await req.Model.find().setOptions(queryOptions).limit(10)
  res.send(items)
})
```
这个时候错误被抛出了，我们要捕获并处理它，所以在最后加一个错误处理函数
```js
// 错误处理函数
app.use(async (err, req, res, next) => {
  res.status(err.statusCode || 500).send({
    message: err.message
  })
})
```
传入四个参数表示错误处理，有的错误可能没有状态码，因此传入500。
当错误信息被发到客户端后，http.js中的拦截器就会拦截错误并弹窗出错误信息。

接下来是几个小地方需要改进
1. 当出现没有token、token错误、没登录的情况时我们应该跳转到登录页面进行登录
在http.js的response拦截器中进行路由跳转
```js
http.interceptors.response.use(res => {
  return res
}, err => {
  if (err.response.data.message) {
    Vue.prototype.$message({
      type: 'error',
      message: err.response.data.message
    })
  }
  if (err.response.status === 401) {
    router.push('/login')
  }
  return Promise.reject(err)
})
```

2. 当没有token的时候我们不应该在请求头中添加authorization
这个时候就在http.js的request拦截器中做一个判断
```js
http.interceptors.request.use(function (config) {
  // 在前端，这个Authorization需要大写，在后端需要小写
  if (localStorage.token) {
    config.headers.Authorization = 'Bearer ' + localStorage.token
  }

  return config
}, function (error) {
  return Promise.reject(error);
});
```

### 封装中间件
我们之前写的服务端验证的代码要在多个接口使用，每个复制就很乱，所以我们把他抽取成一个中间件
我们在server下创建middleware目录用于存放中间件

这些中间件都写成了函数调用的形式，使用时要加上括号去调用这个函数
- middleware/auth.js
```js
module.exports = options => {
  const jwt = require('jsonwebtoken')
  const assert = require('http-assert')
  const AdminUser = require('../models/AdminUser')

  return async (req, res, next) => {
    // 从请求头中获取token（注意在后端这个authorization要小写）
    const token = String(req.headers.authorization || '').split(' ')[1]
    assert(token, 401, '请提供jwt token')
    const {
      id
    } = jwt.verify(token, req.app.get('secret'))
    assert(id, 401, '无效的jwt token')
    req.user = await AdminUser.findById(id)
    assert(req.user, 401, '请先登录')
    await next()
  }
}
```

同理，之前通用接口中匹配模型的代码也能抽出来
- middleware/resource.js
```js
module.exports = options => {
  return async (req, res, next) => {
    const modelName = require('inflection').classify(req.params.resource)
    req.Model = require(`../models/${modelName}`)
    next()
  }
}
```

## 3.4 bug修复
1. 没登录的时候，之间进入创建页发现也能进去，因为创建也并没有发起任何http请求，拦截器根本拦截不了，因此我们设置一个导航守卫，给login路由添加一个meta属性。
```js
path: '/login',
name: 'Login',
component: Login,
meta: {
  isPublic: true
}
```
isPublic表示这个页面是否为能公开访问的。
然后添加导航守卫

```js
router.beforeEach((to, from, next) => {
  if (!to.meta.isPublic && !localStorage.token) {
    return next('/login')
  }
  next()
})
```
当去的页面不是公开访问的（即没有isPublic），并且还没有token的时候，我们就让他跳转到登录页即可

2. 图片上传
上传图片发现抱错，原因是去请求头里面没有Authorization，这是因为我们使用的el-upload它使用的ajax，不能使用我们的axios，因此我们需要在请求头中把Authorization添加进去

由于有多个地方用到了图片上传，因此我们全局定义一个mixin，里面定义一个设置请求头的方法
admin/main.js
```js
Vue.mixin({
  methods:{
    getAuthHeadersMixin(){
      return {
        Authorization:`Bearer ${localStorage.token || ''}`
      }
    }
  }
})
```
然后在ul-upload中添加属性并调用该方法
```js
headers="getAuthHeadersMixin()"
```

# 4. 网页端开发
## 4.1 工具样式
使用scss来写样式，首先写一些基础的工具样式，比如重置样式、文字对齐、字体颜色、大小。最重要的使用border-box。

主要时熟悉sass语法
- 插值语句`#{}`用于使用变量
- 数组
- maps，相当于对象
  - 遍历
  ```scss
  $colors:("a-active-y":#db9e3f,
  "a-active-r":#ff3636,
  "white":#fff,
  "black":#000,
  "primary-font":#222,
  "h3":#212222,
  "a-after":#999,
  "light":#f9f9f9,
  "category":#343440, );

  @each $colorKey,
  $color in $colors {
    .text-#{$colorKey} {
      color: $color;
    }
  
    .bg-#{colorKey} {
      color: $color;
    }
  }
  ```

## 4.2 雪碧图
直接用雪碧牛网站生成css

## 4.3 字体图标
用的是iconfont，添加购物车，下载代码，将压缩包解压直接放到assets下面（一般命名为iconfont），在main.js中引入iconfont.css文件 